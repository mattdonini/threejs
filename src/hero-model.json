{"history":[{"local":{"id":"51645bed-0458-41c4-b253-fc490c9c726a","canvas":{},"ctx":{}},"visible":true,"locked":false,"aspectRatio":1,"isElement":true,"opacity":1,"displace":0,"trackMouse":0,"mouseMomentum":0,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"dispersion":0,"axisTilt":0,"layerType":"image","imageLoaded":false,"effects":["8a210aa1-6ca2-4dee-8f21-5796baa990a6"],"size":0.69,"rotation":0,"height":1080,"repeat":0,"fitToCanvas":1,"scaleX":1,"scaleY":1,"src":"https://assets.unicorn.studio/images/gXKTkjbIUISgIrT65uwcW5lK8q72/hero-image-final.png","speed":0.5,"thumb":"https://assets.unicorn.studio/images/gXKTkjbIUISgIrT65uwcW5lK8q72/hero-image-final_@thumbnail.png?authuser=0","translateX":0,"translateY":0,"width":1920,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.00);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color/(color.a + 0.00000001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"beam","speed":0.25,"trackMouse":-0.2,"mouseMomentum":0.9,"texture":false,"parentLayer":"8a210aa1-6ca2-4dee-8f21-5796baa990a6","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawPoint(vec2 uv, vec2 center, float scale) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.50, 1.-0.50) * 2.; uv = uv * rot(0.00 * TWO_PI) * skew; center = center * rot(0.00 * TWO_PI) * skew; float dist = distance(uv, center); float radius = scale * 0.25;float brightness = radius / (dist); return brightness * vec3(1, 1, 1); }vec3 getBeam(vec2 uv) { vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), -0.20); return drawPoint(uv, pos, 0.78); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv); vec3 beam = getBeam(uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 0.05); result += dither;fragColor = vec4(result, bg.a); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"bloom","texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;out vec4 fragColor;float luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 thresholdPass(vec4 color) { float gamma = 2.2; color.rgb = pow(color.rgb, vec3(1.0/gamma)); color.rgb = 1.2 * (color.rgb - 0.5) + 0.5; vec3 bloom = color.rgb * smoothstep(0.40 - 0.1, 0.40, luma(color)); return vec4(bloom, color.a); }vec4 getColor(vec4 color) { return thresholdPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);if(0.02 == 0.00) { fragColor = color; return; } color = getColor(color); fragColor = color; }","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float radius = 1 > 2 ? 10. : 5.;float amount = (0.33 + 0.2) * radius; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * gaussianWeights[i]; } return color; }vec4 blurPass(vec4 color) { vec2 direction = (1 % 2 == 1) ? vec2(0, 1) : vec2(1, 0); vec4 blurred = GaussianBlur(uTexture, vTextureCoord, direction * vec2(0.50, 1. - 0.50)); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; blurred.rgb += dither; return blurred; }vec4 getColor(vec4 color) { return blurPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);if(0.02 == 0.00) { fragColor = color; return; } color = getColor(color); fragColor = color; }","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float radius = 2 > 2 ? 10. : 5.;float amount = (0.33 + 0.2) * radius; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * gaussianWeights[i]; } return color; }vec4 blurPass(vec4 color) { vec2 direction = (2 % 2 == 1) ? vec2(0, 1) : vec2(1, 0); vec4 blurred = GaussianBlur(uTexture, vTextureCoord, direction * vec2(0.50, 1. - 0.50)); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; blurred.rgb += dither; return blurred; }vec4 getColor(vec4 color) { return blurPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);if(0.02 == 0.00) { fragColor = color; return; } color = getColor(color); fragColor = color; }","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float radius = 3 > 2 ? 10. : 5.;float amount = (0.33 + 0.2) * radius; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * gaussianWeights[i]; } return color; }vec4 blurPass(vec4 color) { vec2 direction = (3 % 2 == 1) ? vec2(0, 1) : vec2(1, 0); vec4 blurred = GaussianBlur(uTexture, vTextureCoord, direction * vec2(0.50, 1. - 0.50)); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; blurred.rgb += dither; return blurred; }vec4 getColor(vec4 color) { return blurPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);if(0.02 == 0.00) { fragColor = color; return; } color = getColor(color); fragColor = color; }","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); float weightSum = 0.0;float radius = 4 > 2 ? 10. : 5.;float amount = (0.33 + 0.2) * radius; float aspectRatio = uResolution.x/uResolution.y;direction.x /= aspectRatio;color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x/1000.) * direction) * gaussianWeights[i]; } return color; }vec4 blurPass(vec4 color) { vec2 direction = (4 % 2 == 1) ? vec2(0, 1) : vec2(1, 0); vec4 blurred = GaussianBlur(uTexture, vTextureCoord, direction * vec2(0.50, 1. - 0.50)); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; blurred.rgb += dither; return blurred; }vec4 getColor(vec4 color) { return blurPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);if(0.02 == 0.00) { fragColor = color; return; } color = getColor(color); fragColor = color; }","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture;out vec4 fragColor;vec3 screen(vec3 src, vec3 dst) { return (src + dst) - (src * dst); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 finalPass(vec4 color) { vec3 bloom = (color.rgb * vec3(1, 1, 1) * 0.02*2.); color.rgb = screen(texture(uBgTexture, vTextureCoord).rgb, bloom) + bloom; return color; }vec4 getColor(vec4 color) { return finalPass(color); }void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);if(0.02 == 0.00) { fragColor = color; return; } color = getColor(color); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":true,"depth":false,"passes":[{"prop":"vertical","value":1,"downSample":true},{"prop":"vertical","value":2,"downSample":true},{"prop":"vertical","value":3,"downSample":true},{"prop":"vertical","value":4,"downSample":true},{"prop":"vertical","value":5,"includeBg":true}]}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"diffuse","amount":0,"speed":0.63,"trackMouse":0,"mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"states":{"appear":[{"type":"appear","id":"c1b80474-6575-486e-a2be-3f1d063c6c45","prop":"amount","value":0.05,"transition":{"ease":"easeInOutExpo","duration":700,"delay":0},"complete":false,"progress":0,"initialStateSet":false,"uniformData":{"type":"1f","name":"uAmount"}}],"scroll":[]},"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uAmount; uniform float uTime; uniform float xy;uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }const float MAX_ITERATIONS = 24.; const float PI = 3.14159265; const float TWOPI = 6.2831853;float random(vec2 seed) { seed.x *= uResolution.x/uResolution.y; return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); float aspectRatio = uResolution.x/uResolution.y; float delta = fract(floor(uTime)/20.); float angle, rotation, amp; float inner = distance(uv * vec2(aspectRatio, 1), pos * vec2(aspectRatio, 1)); float outer = max(0., 1.-distance(uv * vec2(aspectRatio, 1), pos * vec2(aspectRatio, 1))); float amount = uAmount * ease(0, mix(inner, outer, 1.00)) * 2.;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); pos = mPos; float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));amount *= dist;if(amount == 0.) { vec4 color = texture(uTexture, uv); fragColor = color;return; }vec4 result = vec4(0); float threshold = max(1. - 0.51, 2./MAX_ITERATIONS); const float invMaxIterations = 1.0 / float(MAX_ITERATIONS);for(float i = 1.; i <= MAX_ITERATIONS; i++) { float th = i * invMaxIterations; if(th > threshold) break;float random1 = random(uv + th + delta); float random2 = random(uv + th * 2. + delta); float random3 = random(uv + th * 3. + delta); vec2 ranPoint = vec2(random1 * 2. - 1., random2 * 2. - 1.) * mix(1., random3, 0.8); vec2 offset = ranPoint * vec2(1.00, 1.-1.00) * amount * 0.4; offset.x /= aspectRatio; result += texture(uTexture, uv + offset); }result /= floor(MAX_ITERATIONS * threshold);vec4 col =result; fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"grain","intensity":0.18,"speed":0.5,"texture":false,"animating":true,"mouseMomentum":0,"isMask":0,"states":{"appear":[{"type":"appear","id":"f1243c2d-a946-4711-a8f9-05155430ad1e","prop":"intensity","value":0.3,"transition":{"duration":1200,"ease":"easeInOutExpo","delay":70},"complete":false,"progress":0,"initialStateSet":false,"uniformData":{"type":"1f","name":"uAmount"}}],"scroll":[]},"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform float uAmount; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z))); } const float PHI = 1.61803398874989484820459; float gold_noise(in vec2 xy, in float seed) { return fract(tan(distance(xy*PHI, xy)*seed)*xy.x); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); vec2 st = uv; vec3 grainRGB = vec3(0);st *= uResolution;float delta = fract((floor(uTime)/20.));if(0 == 1) { grainRGB = vec3( gold_noise(st, delta + 1.), gold_noise(st, delta + 2.), gold_noise(st, delta + 3.) ); } else { grainRGB = vec3(gold_noise(st, delta + 1.)); } if(5 > 0) { color.rgb = mix(color.rgb, blend(5, grainRGB, color.rgb), uAmount); } fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"texturize","amount":0.12,"chromAbb":5,"glitch":0.01,"speed":1,"texture":false,"animating":true,"mouseMomentum":0,"isMask":0,"states":{"appear":[{"type":"appear","id":"d41cca57-c98d-42d5-81a7-b9943e194332","prop":"glitch","value":0.08,"transition":{"delay":30,"ease":"easeInOutExpo","duration":1000},"complete":false,"progress":0,"initialStateSet":false,"uniformData":{"type":"1f","name":"uGlitch"}},{"type":"appear","id":"9638302b-5643-4882-b1ad-229b6d096a70","prop":"chromAbb","value":30,"transition":{"duration":1000,"ease":"easeInOutExpo","delay":30},"complete":false,"progress":0,"initialStateSet":false,"uniformData":{"type":"1f","name":"uChromAbb"}},{"type":"appear","id":"01829c94-032a-4421-9efd-c804d5f456dd","prop":"amount","value":0.5,"transition":{"delay":30,"ease":"easeInOutExpo","duration":1000},"complete":false,"progress":0,"initialStateSet":false,"uniformData":{"type":"1f","name":"uAmount"}}],"scroll":[]},"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uAmount; uniform float uChromAbb; uniform float uGlitch; uniform float uTime;float random (in float x) { return fract(sin(x)*1e4); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float time = floor(uTime * 0.5) * 2.; float size = uAmount * 0.2 * random(time + 0.001); float floorY = floor(uv.y/size); float floorX = floor(uv.x/size); float phase = 0.01 * 0.01; float phaseTime = phase + uTime; float chromab = uChromAbb * 0.75; float offset = 0.;float glitchMod = max(0., sign(random(sin(floorY + offset + phase)) - 0.5 - (1. - uGlitch*2.)/2.)); float offX = ( (random(floorY + offset * glitchMod + phase)) * 0.01 - 0.01/2. )/5.;uv.x = mix(uv.x, uv.x + offX * 2., glitchMod);float waveFreq = 30.0; float waveAmp = 0.005 * 0.00;float rogue = smoothstep(0., 2., sin((uv.y + 0.01) * waveFreq * (1. - uAmount) * 2. + uTime * 0.05) - 0.5) * 0.2 * 0.00; uv.x += sin(uv.y * waveFreq + uTime) * waveAmp + rogue; uv.y += sin(uv.x * waveFreq + uTime) * waveAmp; float waveX = sin(uv.y * waveFreq + uTime) * waveAmp + rogue * chromab * 0.2;vec4 color = texture(uTexture, uv); color.r = texture(uTexture, vec2(uv.x + (glitchMod * -offX * chromab - waveX), uv.y)).r; color.b = texture(uTexture, vec2(uv.x + (glitchMod * offX * chromab + waveX), uv.y)).b; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"blinds","gradient":0.06,"speed":0.5,"trackMouse":0,"mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"states":{"appear":[{"type":"appear","id":"cb0d4d9d-b221-4be4-9493-0b1edb775308","prop":"gradient","value":0.1,"transition":{"delay":70,"ease":"easeInOutExpo","duration":1200},"complete":false,"progress":0,"initialStateSet":false,"uniformData":{"type":"1f","name":"uAmount"}}],"scroll":[]},"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uAmount; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }const float STEPS = 10.0; const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 scaleAspect(vec2 st, float aspectRatio) { return st * vec2(aspectRatio, 1.0); }vec2 unscaleAspect(vec2 st) { float aspectRatio = uResolution.x / uResolution.y; return st * vec2(1.0/aspectRatio, 1.0); }vec2 rotate(vec2 st, float angle) { float s = sin(angle); float c = cos(angle); mat2 rot = mat2(c, -s, s, c); return rot * st; }struct StructFunc { vec2 st; vec3 distort; };StructFunc style0(vec2 st, vec2 pos, float divisions, float dist, float amount, vec3 first, vec3 second, vec3 third) { float segment = fract((st.y + 1. - pos.y - 1. + uTime * 0.01) * divisions); vec3 distort = mix(mix(first, second, segment * 2.), mix(second, third, (segment - 0.5) / (1. - 0.5)), step(0.5, segment)); st.y -= pow(distort.r, dist) / 10. * amount; st.y += pow(distort.b, dist) / 10. * amount;st = rot(0.00 * 2. * PI) * (st - pos) + pos; st = unscaleAspect(st);return StructFunc(st, distort); }StructFunc getStyle(vec2 st, vec2 pos, float divisions, float dist, float amount, vec3 first, vec3 second, vec3 third) { return style0(st, pos, divisions, dist, amount, first, second, third); }vec4 blinds(vec2 st, float mDist) { float aspectRatio = uResolution.x / uResolution.y; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.00) * floor(1.00); pos = scaleAspect(pos, aspectRatio); st = scaleAspect(st, aspectRatio);st = rotate(st - pos, -0.00 * 2.0 * PI) + pos;vec3 first = vec3(1, 0, 0); vec3 second = vec3(0, 1, 0); vec3 third = vec3(0, 0, 1); float divisions = 2. + -30.00 * 30.; float dist = 1.00 * 4. + 1.; float amount = uAmount * mDist;StructFunc result = getStyle(st, pos, divisions, dist, amount, first, second, third); vec4 color = texture(uTexture, result.st);return color; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x / uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.00); vec2 pos = mPos; float mDist = ease(0, max(0., 1. - distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));vec4 col = blinds(uv, mDist); fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"custom","speed":0.66,"mouseMomentum":0.9,"texture":{"name":"texture-zoomed.png","thumb":"https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/gXKTkjbIUISgIrT65uwcW5lK8q72%2Ftexture-zoomed_%40thumbnail.png?alt=media&token=ce35e964-2150-44d1-a813-1c42316c41e6","sampler":"uCustomTexture","src":"https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/gXKTkjbIUISgIrT65uwcW5lK8q72%2Ftexture-zoomed.png?alt=media&token=ce35e964-2150-44d1-a813-1c42316c41e6"},"animating":true,"isMask":0,"customFragmentShaders":["#version 300 es\nprecision mediump float;\n\n// Input texture coordinates from the vertex shader\nin vec2 vTextureCoord;\n\n// Define the uniforms\nuniform vec2 uResolution;         // width and height of the screen\nuniform vec2 uMousePos;           // mouse position\nuniform float uAmount;            // scale factor for the 3D effect intensity\nuniform sampler2D uTexture;       // main texture\nuniform sampler2D uCustomTexture; // depth map\n\n// Define the output color\nout vec4 fragColor;\n\n// Function to handle mirrored UVs\nvec2 mirrored(vec2 v) {\n    vec2 m = mod(v, 2.0);\n    return mix(m, 2.0 - m, step(1.0, m));\n}\n\nvoid main() {\n    vec2 uv = vTextureCoord;\n\n    // Calculate aspect ratios\n    float textureAspectRatio = float(textureSize(uCustomTexture, 0).x) / float(textureSize(uCustomTexture, 0).y);\n    float windowAspectRatio = uResolution.x / uResolution.y;\n\n    // Determine the scaling factor and offsets\n    vec2 scale = vec2(1.0);\n    vec2 offset = vec2(0.0);\n    \n    if (windowAspectRatio > textureAspectRatio) {\n        scale.y = textureAspectRatio / windowAspectRatio;\n        offset.y = (1.0 - scale.y) * 0.5;\n    } else {\n        scale.x = windowAspectRatio / textureAspectRatio;\n        offset.x = (1.0 - scale.x) * 0.5;\n    }\n\n    // Adjust and center the texture coordinates\n    vec2 adjustedUv = uv * scale + offset;\n\n    // Get the texture from the depth map\n    vec4 depthMap = texture(uCustomTexture, mirrored(adjustedUv));\n\n    // Calculate the fake 3D offset\n    vec2 offset3D = (depthMap.r - 0.5) * uAmount * (uMousePos - vec2(0.5));\n\n    // Apply the fake 3D offset\n    vec2 fake3d = uv + offset3D;\n\n    // Get the color from the main texture using the fake 3D coordinates\n    vec4 color = texture(uTexture, mirrored(fake3d));\n\n    // Set the output color of our pixel to the main texture color\n    fragColor = color;\n}\n"],"customVertexShaders":["#version 300 es\nprecision mediump float;\n\nin vec3 aVertexPosition;\nin vec2 aTextureCoord;\n\nout vec2 vTextureCoord;\nout vec3 vVertexPosition;\n\nvoid main() {\n    gl_Position = vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n}"],"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uTexture; uniform sampler2D uCustomTexture;out vec4 fragColor;vec2 mirrored(vec2 v) { vec2 m = mod(v, 2.0); return mix(m, 2.0 - m, step(1.0, m)); }void main() { vec2 uv = vTextureCoord; float textureAspectRatio = float(textureSize(uCustomTexture, 0).x) / float(textureSize(uCustomTexture, 0).y); float windowAspectRatio = uResolution.x / uResolution.y; vec2 scale = vec2(1.0); vec2 offset = vec2(0.0); if (windowAspectRatio > textureAspectRatio) { scale.y = textureAspectRatio / windowAspectRatio; offset.y = (1.0 - scale.y) * 0.5; } else { scale.x = windowAspectRatio / textureAspectRatio; offset.x = (1.0 - scale.x) * 0.5; } vec2 adjustedUv = uv * scale + offset; vec4 depthMap = texture(uCustomTexture, mirrored(adjustedUv)); vec2 offset3D = (depthMap.r - 0.5) * -0.05 * (uMousePos - vec2(0.5)); vec2 fake3d = uv + offset3D; vec4 color = texture(uTexture, mirrored(fake3d)); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false}}],"options":{"name":"NOPE","fps":120,"dpi":2,"scale":1,"includeLogo":false,"isProduction":1,"version":"1.2.7"},"version":"1.2.7"}