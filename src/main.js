import"./styles/style.css";import*as THREE from"three";import{GLTFLoader}from"three/examples/jsm/loaders/GLTFLoader.js";import{EffectComposer}from"three/examples/jsm/postprocessing/EffectComposer.js";import{RenderPass}from"three/examples/jsm/postprocessing/RenderPass.js";import{ShaderPass}from"three/examples/jsm/postprocessing/ShaderPass.js";const canvas=document.querySelector("canvas.webgl"),scene=new THREE.Scene;scene.background=null;const sizes={width:window.innerWidth,height:window.innerHeight},debounce=(e,t)=>{let o;return(...n)=>{clearTimeout(o),o=setTimeout((()=>{requestAnimationFrame((()=>e.apply(this,n)))}),t)}};window.addEventListener("resize",debounce((()=>{sizes.width=window.innerWidth,sizes.height=window.innerHeight,camera.aspect=sizes.width/sizes.height,camera.updateProjectionMatrix(),renderer.setSize(sizes.width,sizes.height),renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)),composer.setSize(sizes.width,sizes.height),adjustModelScale()}),100));const camera=new THREE.PerspectiveCamera(75,sizes.width/sizes.height,.1,100);camera.position.set(0,0,2),scene.add(camera);const renderer=new THREE.WebGLRenderer({canvas:canvas,antialias:!0,alpha:!0});renderer.setClearColor(0,0),renderer.setSize(sizes.width,sizes.height),renderer.setPixelRatio(Math.min(window.devicePixelRatio,2)),renderer.outputEncoding=THREE.sRGBEncoding,renderer.shadowMap.enabled=!0;const loader=new GLTFLoader,textureLoader=new THREE.TextureLoader;let model,currentModelUrl="";const modelCache={},textureCache={},preFetchAssets=()=>{document.querySelectorAll("[data-3d-url]").forEach((e=>{const t=e.getAttribute("data-3d-url");t&&!modelCache[t]&&loader.load(t,(e=>{modelCache[t]=e}))})),document.querySelectorAll("[data-texture-url]").forEach((e=>{const t=e.getAttribute("data-texture-url");t&&!textureCache[t]&&textureLoader.load(t,(e=>{textureCache[t]=e}))}))};document.querySelectorAll("[data-3d-url]").forEach((e=>{const t=e.getAttribute("data-3d-url");t&&!modelCache[t]&&loader.load(t,(e=>{modelCache[t]=e}))})),document.querySelectorAll("[data-texture-url]").forEach((e=>{const t=e.getAttribute("data-texture-url");t&&!textureCache[t]&&textureLoader.load(t,(e=>{textureCache[t]=e}))}));const loadModel=(e,t)=>{modelCache[e]?(model&&scene.remove(model),model=modelCache[e].scene.clone(),updateModelTexture(currentTextureUrl),model.position.set(0,0,0),adjustModelScale(),scene.add(model),currentModelUrl=e,t&&t()):loader.load(e,(o=>{model&&scene.remove(model),model=o.scene,updateModelTexture(currentTextureUrl),model.position.set(0,0,0),adjustModelScale(),scene.add(model),currentModelUrl=e,t&&t()}),void 0,console.error)};let currentTextureUrl="";const updateModelTexture=e=>{if(model&&e){const t=textureCache[e]||textureLoader.load(e);t.encoding=THREE.sRGBEncoding,model.traverse((e=>{e.isMesh&&(e.material=new THREE.MeshMatcapMaterial({matcap:t,transparent:!0,opacity:1}),e.castShadow=!0,e.receiveShadow=!0)})),currentTextureUrl=e}};loadModel("https://uploads-ssl.webflow.com/6665a67f8e924fdecb7b36e5/6675c8cc5cc9e9c9c8156f5d_holographic_hodie.gltf.txt",(()=>{currentTextureUrl="https://uploads-ssl.webflow.com/6665a67f8e924fdecb7b36e5/6675a742ad653905eaedaea8_holographic-texture.webp",updateModelTexture(currentTextureUrl)}));const mouse={x:0,y:0};window.addEventListener("mousemove",(e=>{mouse.x=e.clientX/window.innerWidth*2-1,mouse.y=e.clientY/window.innerHeight*2-1}));const lerp=(e,t,o)=>(1-o)*e+o*t;let lastRotationX=0,lastRotationY=0,rotationVelocityX=0,rotationVelocityY=0;const vertexShader="\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader="\nuniform sampler2D tDiffuse;\nuniform vec2 rotationVelocity;\nvarying vec2 vUv;\n\nvoid main() {\n    vec2 uv = vUv;\n    vec4 color = texture2D(tDiffuse, uv);\n\n    // RGB offsets for chromatic aberration\n    vec2 offsetR = rotationVelocity * 0.15; // Adjust the multiplier for noticeable effect\n    vec2 offsetG = rotationVelocity * 0.10;\n    vec2 offsetB = rotationVelocity * 0.12;\n    vec4 colorR = texture2D(tDiffuse, uv + offsetR);\n    vec4 colorG = texture2D(tDiffuse, uv - offsetG);\n    vec4 colorB = texture2D(tDiffuse, uv + offsetB);\n\n    // Smooth the edges by blending the channels slightly\n    vec4 finalColor = vec4(\n        mix(color.r, colorR.r, 0.5),\n        mix(color.g, colorG.g, 0.5),\n        mix(color.b, colorB.b, 0.5),\n        color.a\n    );\n\n    gl_FragColor = finalColor; // Use the final color with RGB effect\n}\n",pixelationVertexShader="\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",pixelationFragmentShader="\nuniform sampler2D tDiffuse;\nuniform float pixelSize;\nuniform vec2 resolution;\nvarying vec2 vUv;\n\nvoid main() {\n    vec2 uv = vUv;\n\n    // Pixelation effect\n    if (pixelSize > 0.0) {\n        uv = floor(uv / pixelSize) * pixelSize;\n    }\n\n    // Fetch the texture color\n    vec4 color = texture2D(tDiffuse, uv);\n\n    // Glitch effect: random offsets\n    float glitchIntensity = 0.95 * pixelSize;\n    vec2 glitchOffset = vec2(glitchIntensity * (fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453) - 0.5), 0.0);\n\n    // RGB distortion effect\n    vec2 offsetR = glitchOffset;\n    vec2 offsetG = vec2(0.0);\n    vec2 offsetB = -glitchOffset;\n\n    vec4 colorR = texture2D(tDiffuse, uv + offsetR);\n    vec4 colorG = texture2D(tDiffuse, uv + offsetG);\n    vec4 colorB = texture2D(tDiffuse, uv + offsetB);\n\n    // Combine the RGB channels with the glitch effect\n    gl_FragColor = vec4(colorR.r, colorG.g, colorB.b, color.a);\n}\n",noiseFragmentShader="\nuniform sampler2D tDiffuse;\nuniform float time;\nuniform float noiseStrength;\nvarying vec2 vUv;\n\nfloat random(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vec4 color = texture2D(tDiffuse, vUv);\n    float noise = random(vUv + time) * noiseStrength;\n    color.rgb += noise * 0.15; // Adjust the multiplier for noise intensity\n    gl_FragColor = color;\n}\n",glitchVertexShader="\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",glitchFragmentShader="\nprecision mediump float;\nvarying vec2 vUv;\nuniform sampler2D tDiffuse;\nuniform float uAmount;\nuniform float uChromAbb;\nuniform float uGlitch;\nuniform float uTime;\n\nfloat random(in float x) {\n    return fract(sin(x)*1e4);\n}\n\nvoid main() {\n    vec2 uv = vUv;\n    float time = floor(uTime * 0.5) * 2.;\n    float size = uAmount * 0.2 * random(time + 0.001);\n    float floorY = floor(uv.y / size);\n    float floorX = floor(uv.x / size);\n    float phase = 0.01 * 0.01;\n    float phaseTime = phase + uTime;\n    float chromab = uChromAbb * 0.75;\n    float offset = 0.;\n    float glitchMod = max(0., sign(random(sin(floorY + offset + phase)) - 0.5 - (1. - uGlitch*2.) / 2.));\n    float offX = ((random(floorY + offset * glitchMod + phase)) * 0.01 - 0.01 / 2.) / 5.;\n    uv.x = mix(uv.x, uv.x + offX * 2., glitchMod);\n    float waveFreq = 30.0;\n    float waveAmp = 0.005 * 0.00;\n    float rogue = smoothstep(0., 2., sin((uv.y + 0.01) * waveFreq * (1. - uAmount) * 2. + uTime * 0.05) - 0.5) * 0.2 * 0.00;\n    uv.x += sin(uv.y * waveFreq + uTime) * waveAmp + rogue;\n    uv.y += sin(uv.x * waveFreq + uTime) * waveAmp;\n    float waveX = sin(uv.y * waveFreq + uTime) * waveAmp + rogue * chromab * 0.2;\n    vec4 color = texture(tDiffuse, uv);\n    color.r = texture(tDiffuse, vec2(uv.x + (glitchMod * -offX * chromab - waveX), uv.y)).r;\n    color.b = texture(tDiffuse, vec2(uv.x + (glitchMod * offX * chromab + waveX), uv.y)).b;\n    gl_FragColor = color;\n}\n",blindsVertexShader="\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",blindsFragmentShader="\nprecision mediump float;\nuniform sampler2D tDiffuse;\nuniform float uAmount;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nvarying vec2 vUv;\n\nfloat ease (int easingFunc, float t) {\n    return t;\n}\nconst float STEPS = 10.0;\nconst float PI = 3.14159265359;\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\nvec2 scaleAspect(vec2 st, float aspectRatio) {\n    return st * vec2(aspectRatio, 1.0);\n}\nvec2 unscaleAspect(vec2 st) {\n    float aspectRatio = uResolution.x / uResolution.y;\n    return st * vec2(1.0/aspectRatio, 1.0);\n}\nvec2 rotate(vec2 st, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    return rot * st;\n}\nstruct StructFunc {\n    vec2 st;\n    vec3 distort;\n};\nStructFunc style0(vec2 st, vec2 pos, float divisions, float dist, float amount, vec3 first, vec3 second, vec3 third) {\n    float segment = fract((st.y + 1. - pos.y - 1. + uTime * 0.01) * divisions);\n    vec3 distort = mix(mix(first, second, segment * 2.), mix(second, third, (segment - 0.5) / (1. - 0.5)), step(0.5, segment));\n    st.y -= pow(distort.r, dist) / 10. * amount;\n    st.y += pow(distort.b, dist) / 10. * amount;\n    st = rot(0.00 * 2. * PI) * (st - pos) + pos;\n    st = unscaleAspect(st);\n    return StructFunc(st, distort);\n}\nStructFunc getStyle(vec2 st, vec2 pos, float divisions, float dist, float amount, vec3 first, vec3 second, vec3 third) {\n    return style0(st, pos, divisions, dist, amount, first, second, third);\n}\nvec4 blinds(vec2 st, float mDist) {\n    float aspectRatio = uResolution.x / uResolution.y;\n    vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.00) * floor(1.00);\n    pos = scaleAspect(pos, aspectRatio);\n    st = scaleAspect(st, aspectRatio);\n    st = rotate(st - pos, -0.00 * 2.0 * PI) + pos;\n    vec3 first = vec3(1, 0, 0);\n    vec3 second = vec3(0, 1, 0);\n    vec3 third = vec3(0, 0, 1);\n    float divisions = 2. + -30.00 * 30.;\n    float dist = 1.00 * 4. + 1.;\n    float amount = uAmount * mDist;\n    StructFunc result = getStyle(st, pos, divisions, dist, amount, first, second, third);\n    vec4 color = texture2D(tDiffuse, result.st);\n    return color;\n}\n\nvoid main() {\n    gl_FragColor = blinds(vUv, 1.0);\n}\n",diffuseVertexShader="\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",diffuseFragmentShader="\nprecision mediump float;\n\nvarying vec2 vUv;\n\nuniform sampler2D tDiffuse;\nuniform float uTime;\nuniform float xy;\nuniform float amount; // New uniform for controlling amount\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\n\nfloat ease(int easingFunc, float t) { \n    return t; \n}\n\nconst float MAX_ITERATIONS = 24.0;\nconst float PI = 3.14159265;\nconst float TWOPI = 6.2831853;\n\nfloat random(vec2 seed) { \n    seed.x *= uResolution.x / uResolution.y; \n    return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); \n}\n\nvoid main() {\n    vec2 uv = vUv;\n    vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.00); \n    float aspectRatio = uResolution.x / uResolution.y;\n    float delta = fract(floor(uTime) / 20.0);\n\n    float angle, rotation, amp;\n    float inner = distance(uv * vec2(aspectRatio, 1.0), pos * vec2(aspectRatio, 1.0));\n    float outer = max(0.0, 1.0 - distance(uv * vec2(aspectRatio, 1.0), pos * vec2(aspectRatio, 1.0)));\n    float amt = amount * ease(0, mix(inner, outer, 0.11)) * 2.0;\n    vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.00); \n    pos = vec2(0.5, 0.5);\n    float dist = ease(0, max(0.0, 1.0 - distance(uv * vec2(aspectRatio, 1.0), mPos * vec2(aspectRatio, 1.0)) * 4.0 * (1.0 - 1.00)));\n    amt *= dist;\n\n    if (amt == 0.0) {\n        vec4 color = texture2D(tDiffuse, uv);\n        gl_FragColor = color;\n        return;\n    }\n\n    vec4 result = vec4(0);\n    float threshold = max(1.0 - 0.53, 2.0 / MAX_ITERATIONS);\n    const float invMaxIterations = 1.0 / float(MAX_ITERATIONS);\n\n    for (float i = 1.0; i <= MAX_ITERATIONS; i++) {\n        float th = i * invMaxIterations;\n        if (th > threshold) break;\n        float random1 = random(uv + th + delta);\n        float random2 = random(uv + th * 2.0 + delta);\n        float random3 = random(uv + th * 3.0 + delta);\n        vec2 ranPoint = vec2(random1 * 2.0 - 1.0, random2 * 2.0 - 1.0) * mix(1.0, random3, 0.8);\n        vec2 offset = ranPoint * vec2(0.91, 1.0 - 0.91) * amt * 0.4;\n        offset.x /= aspectRatio;\n        result += texture2D(tDiffuse, uv + offset);\n    }\n\n    result /= floor(MAX_ITERATIONS * threshold);\n    vec4 col = result;\n    gl_FragColor = col;\n}\n",composer=new EffectComposer(renderer),renderPass=new RenderPass(scene,camera);composer.addPass(renderPass);const customPass=new ShaderPass({uniforms:{tDiffuse:{value:null},rotationVelocity:{value:new THREE.Vector2}},vertexShader:vertexShader,fragmentShader:fragmentShader});customPass.renderToScreen=!0,composer.addPass(customPass);const pixelationPass=new ShaderPass({uniforms:{tDiffuse:{value:null},pixelSize:{value:0},resolution:{value:new THREE.Vector2(sizes.width,sizes.height)}},vertexShader:pixelationVertexShader,fragmentShader:pixelationFragmentShader});composer.addPass(pixelationPass);const noisePass=new ShaderPass({uniforms:{tDiffuse:{value:null},time:{value:0},noiseStrength:{value:0}},vertexShader:vertexShader,fragmentShader:noiseFragmentShader});composer.addPass(noisePass);const glitchPass=new ShaderPass({uniforms:{tDiffuse:{value:null},uAmount:{value:0},uChromAbb:{value:0},uGlitch:{value:0},uTime:{value:0}},vertexShader:glitchVertexShader,fragmentShader:glitchFragmentShader});composer.addPass(glitchPass);const blindsPass=new ShaderPass({uniforms:{tDiffuse:{value:null},uAmount:{value:0},uTime:{value:0},uMousePos:{value:new THREE.Vector2(.5,.5)},uResolution:{value:new THREE.Vector2(sizes.width,sizes.height)}},vertexShader:blindsVertexShader,fragmentShader:blindsFragmentShader});composer.addPass(blindsPass);const diffusePass=new ShaderPass({uniforms:{tDiffuse:{value:null},uTime:{value:0},xy:{value:0},amount:{value:.13},uMousePos:{value:new THREE.Vector2(.5,.5)},uResolution:{value:new THREE.Vector2(sizes.width,sizes.height)}},vertexShader:diffuseVertexShader,fragmentShader:diffuseFragmentShader});composer.addPass(diffusePass),glitchPass.enabled=!1,blindsPass.enabled=!1,diffusePass.enabled=!1;const adjustModelScale=()=>{if(model){const e=2,t=2.5,o=sizes.width<768,n=o?sizes.width/1200:sizes.width/1500,s=o?sizes.height/1200:sizes.height/1500;let r=Math.min(n,s);r=Math.max(e,Math.min(r,t)),model.scale.set(r,r,r)}},easeInOutQuad=e=>e<.5?2*e*e:(4-2*e)*e-1,animate=()=>{if(requestAnimationFrame(animate),model){model.position.set(0,0,0);const e=.2,t=.2;model.rotation.x=lerp(model.rotation.x,mouse.y*e,.1),model.rotation.y=lerp(model.rotation.y,mouse.x*t,.1),rotationVelocityX=model.rotation.x-lastRotationX,rotationVelocityY=model.rotation.y-lastRotationY,lastRotationX=model.rotation.x,lastRotationY=model.rotation.y}customPass.uniforms.rotationVelocity.value.set(rotationVelocityY,rotationVelocityX),noisePass.uniforms.time.value+=.05,glitchPass.uniforms.uTime.value+=.05,blindsPass.uniforms.uTime.value+=.05,diffusePass.uniforms.uTime.value+=.05,composer.render()};animate(),document.querySelectorAll("[data-garment-id]").forEach((e=>{e.addEventListener("click",(()=>{const t=e.getAttribute("data-3d-url");if(t){const e=350,o=450,n=performance.now();glitchPass.enabled=!0,blindsPass.enabled=!0,diffusePass.enabled=!0;const s=()=>{const o=performance.now()-n,a=Math.min(o/e,1),i=easeInOutQuad(a);pixelationPass.uniforms.pixelSize.value=.006*i,noisePass.uniforms.noiseStrength.value=.5*i,glitchPass.uniforms.uAmount.value=16*i,glitchPass.uniforms.uChromAbb.value=2*i,glitchPass.uniforms.uGlitch.value=4*i,blindsPass.uniforms.uAmount.value=.2*i,diffusePass.uniforms.xy.value=1*i,diffusePass.uniforms.amount.value=.12*i,a<1?requestAnimationFrame(s):loadModel(t,r)},r=()=>{const e=performance.now(),t=()=>{const n=performance.now()-e,s=(Math.min(n/o,1),easeInOutQuad(1-n/o));pixelationPass.uniforms.pixelSize.value=.01*s,noisePass.uniforms.noiseStrength.value=.5*s,glitchPass.uniforms.uAmount.value=5*s,glitchPass.uniforms.uChromAbb.value=3*s,glitchPass.uniforms.uGlitch.value=6*s,blindsPass.uniforms.uAmount.value=.2*s,diffusePass.uniforms.xy.value=2*s,diffusePass.uniforms.amount.value=.1*s,n<o?requestAnimationFrame(t):(pixelationPass.uniforms.pixelSize.value=0,noisePass.uniforms.noiseStrength.value=0,glitchPass.uniforms.uAmount.value=0,glitchPass.uniforms.uChromAbb.value=0,glitchPass.uniforms.uGlitch.value=0,blindsPass.uniforms.uAmount.value=0,diffusePass.uniforms.xy.value=0,diffusePass.uniforms.amount.value=0,glitchPass.enabled=!1,blindsPass.enabled=!1,diffusePass.enabled=!1)};t()};s()}else console.error("No model URL found for this element")}))}));let currentActiveGarment=null,currentActiveThread=null;document.addEventListener("DOMContentLoaded",(function(){(function(e){const t=document.querySelectorAll(e),o=[];return t.forEach((e=>{const t=e.getAttribute("src");if(t){const n=new Promise(((o,n)=>{const s=new Image;s.src=t,s.onload=()=>{e.src=s.src,o()},s.onerror=n}));o.push(n)}})),Promise.all(o)})(".img.is-garment, .img.is-garment-2, .img.is-garment-3").then((()=>{const e=document.querySelector(".garment_item");e&&(currentActiveGarment=e,currentActiveGarment.classList.add("active"),currentActiveGarment.classList.add("inner-shadow"),n(currentActiveGarment,"1"));const t=document.querySelector(".threads_trigger-item");var o;function n(e,t){e.querySelectorAll(".img.is-garment, .img.is-garment-2, .img.is-garment-3").forEach((e=>{e.style.opacity=t}))}function s(e,t){const o=e.querySelector(".paragraph.is-support-medium.is-selector.is-scramble");o&&(t?o.classList.add("active"):o.classList.remove("active"))}function r(e){document.querySelectorAll(".img.is-garment, .img.is-garment-2, .img.is-garment-3").forEach((e=>{e.style.display="none"}));const t=".img.is-garment"+(0===e?"":"-"+(e+1));document.querySelectorAll(t).forEach((e=>{e.style.display="block"})),currentActiveGarment&&n(currentActiveGarment,"1")}function a(e,t,o,n,r=!1){const a=document.querySelectorAll(e),i=o?document.querySelector(o):null;let l=null;a.forEach((o=>{const c=o.querySelectorAll(t);0!==c.length?(o.addEventListener("mouseenter",(function(){".garment_item"===e&&currentActiveGarment!==o?(c.forEach((e=>{e.style.opacity="0.8"})),o.classList.add("hover-inner-shadow")):".threads_trigger-item"===e&&currentActiveThread!==o&&c.forEach((e=>{e.style.opacity="0.8"}))})),o.addEventListener("mouseleave",(function(){".garment_item"===e&&currentActiveGarment!==o?(c.forEach((e=>{e.style.opacity="0.5"})),o.classList.remove("hover-inner-shadow")):".threads_trigger-item"===e&&currentActiveThread!==o&&c.forEach((e=>{e.style.opacity="0.5"}))})),o.addEventListener("click",(function(){o.classList.contains("active")||(a.forEach((e=>{e.querySelectorAll(t).forEach((e=>{e.style.opacity="0.5"})),n&&e.classList.remove("inner-shadow"),e.classList.remove("hover-inner-shadow"),e.classList.remove("active"),s(e,!1)})),c.forEach((e=>{e.style.opacity="1"})),n&&o.classList.add("inner-shadow"),o.classList.add("active"),s(o,!0),".garment_item"===e?currentActiveGarment=o:currentActiveThread=o,i&&(!function(e){if(i){const t=e.getBoundingClientRect(),o=e.offsetParent.getBoundingClientRect();i.style.top=t.top-o.top-.25*window.innerWidth/100+"px",r||(i.style.left=t.left-o.left-.25*window.innerWidth/100+"px")}}(o),i.classList.add("inner-shadow")),function(e){const t=e.querySelector(".paragraph.is-support-medium.is-selector.is-scramble");t&&t!==l&&(l&&l.classList.remove("active"),t.classList.add("active"),l=t)}(o))}))):console.error(`Image with class ${t} not found in item`,o)})),document.addEventListener("click",(function(t){!t.target.closest(e)&&l&&l.classList.add("active")}))}t&&(currentActiveThread=t,currentActiveThread.classList.add("active"),o="1",t.querySelectorAll(".img.is-threads").forEach((e=>{e.style.opacity=o})),s(t,!0)),a(".garment_item",".img.is-garment, .img.is-garment-2, .img.is-garment-3",".garment_corner-wrap",!0),a(".threads_trigger-item",".img.is-threads",".threads_corner",!1,!0),a(".threads_img",".img.is-threads",null,!1),document.querySelectorAll("[data-threads-id]").forEach(((e,t)=>{e.addEventListener("click",(()=>{const o=e.getAttribute("data-texture-url");o?updateModelTexture(o):console.error("No texture URL found for this element"),r(t)}))})),r(0);const i=document.querySelector(".garment_item .img.is-garment");i&&(i.style.opacity="1"),gsap.registerPlugin(ScrollTrigger),gsap.fromTo("#canvas3d",{filter:"blur(20px)"},{filter:"blur(0px)",duration:2,ease:"power2.out",delay:.5,scrollTrigger:{trigger:"#stickyWrap",start:"top bottom",end:"top top",once:!0}});gsap.timeline({scrollTrigger:{trigger:"#stickyWrap",start:"top top",end:"bottom bottom",scrub:!0}}).to("#canvas3d",{y:"100vh",ease:"power2.inOut",scrollTrigger:{trigger:"#stickyWrap",start:"top top",end:"bottom bottom",scrub:!0,onUpdate:e=>{1===e.progress&&(gsap.set("#canvas3d",{y:"100vh",immediateRender:!1}),ScrollTrigger.getById("canvas3dScrollTrigger").disable())},onLeave:()=>{gsap.set("#canvas3d",{y:"100vh"})},onLeaveBack:()=>{gsap.set("#canvas3d",{y:"0"})},id:"canvas3dScrollTrigger"}})})).catch((e=>{console.error("Error preloading images:",e)}))}));