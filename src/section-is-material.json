{"history":[{"local":{"id":"b3727a80-a748-422c-b1a6-28901ef75ed2","canvas":{},"ctx":{}},"visible":true,"locked":false,"aspectRatio":1,"isElement":true,"opacity":1,"displace":0,"trackMouse":0.2,"mouseMomentum":0.4,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"dispersion":0,"axisTilt":0,"layerType":"image","imageLoaded":false,"effects":[],"size":0.25,"rotation":0,"height":1238,"repeat":0,"fitToCanvas":1,"scaleX":1,"scaleY":1,"src":"https://assets.unicorn.studio/images/gXKTkjbIUISgIrT65uwcW5lK8q72/test2.png","speed":0.5,"thumb":"https://assets.unicorn.studio/images/gXKTkjbIUISgIrT65uwcW5lK8q72/test2_@thumbnail.png?authuser=0","translateX":0,"translateY":0,"width":1368,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.20);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color/(color.a + 0.00000001), color.a * 1.00);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25; mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"]},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"noise","speed":0.25,"trackMouse":0,"mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;void main() { vec2 noise = vTextureCoord; vec2 uv = vVertexPosition.xy; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 pos = mPos; float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));uv = mix(uv, noise, dist);vec4 color = texture(uTexture, uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float; in vec3 aVertexPosition; in vec2 aTextureCoord; uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec3 vVertexPosition; out vec2 vTextureCoord;uniform float uTime; uniform sampler2D uMaskTexture; uniform vec2 uMousePos; uniform vec2 uResolution;vec4 permute(vec4 t) { return t * (t * 34.0 + 133.0); } vec3 grad(float hash) { vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0; vec3 cuboct = cube; cuboct[int(hash / 16.0)] = 0.0; float type = mod(floor(hash / 8.0), 2.0); vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct)); vec3 grad = cuboct * 1.22474487139 + rhomb; grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184; return grad; } vec4 bccNoiseDerivativesPart(vec3 X) { vec3 b = floor(X); vec4 i4 = vec4(X - b, 2.5); vec3 v1 = b + floor(dot(i4, vec4(.25))); vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35))); vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35))); vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35))); vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0)); hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0)); hashes = mod(permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0)), 48.0); vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4; vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0); vec4 aa = a * a; vec4 aaaa = aa * aa; vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y); vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w); vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4)); vec3 derivative = -8.0 * mat4x3(d1, d2, d3, d4) * (aa * a * extrapolations) + mat4x3(g1, g2, g3, g4) * aaaa; return vec4(derivative, dot(aaaa, extrapolations)); } vec4 bccNoiseDerivatives_XYZ(vec3 X) { X = dot(X, vec3(2.0/3.0)) - X; vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5); return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w); } vec4 bccNoiseDerivatives_XYBeforeZ(vec3 X) { mat3 orthonormalMap = mat3( 0.788675134594813, -0.211324865405187, -0.577350269189626, -0.211324865405187, 0.788675134594813, -0.577350269189626, 0.577350269189626, 0.577350269189626, 0.577350269189626); X = orthonormalMap * X; vec4 result = bccNoiseDerivativesPart(X) + bccNoiseDerivativesPart(X + 144.5); return vec4(result.xyz * orthonormalMap, result.w); }const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec3 vertexPosition = aVertexPosition; vec2 textureCoord = (vertexPosition.xy+1.) / 2.; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); vec2 st = vec2(textureCoord.x * uResolution.x/uResolution.y, textureCoord.y) - pos; st = rot(0.00 * -1. * 2.0 * PI) * (st); vec4 noise = bccNoiseDerivatives_XYBeforeZ(vec3(st * vec2(0.73, 1. - 0.73) * 9. * 0.96, 0.00 + uTime*0.02)); st.xy = mix(textureCoord, (noise.xy/7. + 0.5), 0.55); gl_Position = uPMatrix * uMVMatrix * vec4(vertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(st, 0.0, 1.0)).xy; vVertexPosition = vec3(aTextureCoord, 0.); }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"blinds","speed":0.05,"trackMouse":0,"mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { return t; }const float STEPS = 10.0; const float PI = 3.14159265359;mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 scaleAspect(vec2 st, float aspectRatio) { return st * vec2(aspectRatio, 1.0); }vec2 unscaleAspect(vec2 st) { float aspectRatio = uResolution.x / uResolution.y; return st * vec2(1.0/aspectRatio, 1.0); }vec2 rotate(vec2 st, float angle) { float s = sin(angle); float c = cos(angle); mat2 rot = mat2(c, -s, s, c); return rot * st; }struct StructFunc { vec2 st; vec3 distort; };StructFunc style4(vec2 st, vec2 pos, float divisions, float dist, float amount, vec3 first, vec3 second, vec3 third) { vec2 diff = st - pos; float radius = length(diff); float segment = fract(radius * divisions - uTime * 0.01); vec3 distort = mix(mix(first, second, segment * 2.), mix(second, third, (segment - 0.5) / (1. - 0.5)), step(0.5, segment)); st -= pow(distort.r, dist) / 10. * amount * normalize(diff); st += pow(distort.b, dist) / 10. * amount * normalize(diff);st = rot(0.12 * 2. * PI) * (st - pos) + pos; st = unscaleAspect(st);return StructFunc(st, distort); }StructFunc getStyle(vec2 st, vec2 pos, float divisions, float dist, float amount, vec3 first, vec3 second, vec3 third) { return style4(st, pos, divisions, dist, amount, first, second, third); }vec4 blinds(vec2 st, float mDist) { float aspectRatio = uResolution.x / uResolution.y; vec2 pos = vec2(0.50186799501868, 0.4962640099626401) + mix(vec2(0), (uMousePos - 0.5), 0.00) * floor(1.00); pos = scaleAspect(pos, aspectRatio); st = scaleAspect(st, aspectRatio);st = rotate(st - pos, -0.12 * 2.0 * PI) + pos;vec3 first = vec3(1, 0, 0); vec3 second = vec3(0, 1, 0); vec3 third = vec3(0, 0, 1); float divisions = 2. + 0.30 * 30.; float dist = 1.00 * 4. + 1.; float amount = 1.00 * mDist;StructFunc result = getStyle(st, pos, divisions, dist, amount, first, second, third); vec4 color = texture(uTexture, result.st);return color; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float aspectRatio = uResolution.x / uResolution.y;vec2 mPos = vec2(0.50186799501868, 0.4962640099626401) + mix(vec2(0), (uMousePos - 0.5), 0.00); vec2 pos = mPos; float mDist = ease(0, max(0., 1. - distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.00)));vec4 col = blinds(uv, mDist); fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"blur","trackMouse":0,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 0 <= 1 ? 6. : 11.; float amount = (0.03 * amt) * ease(0, mix(inner, outer, 0.50)); color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.50, 1. - 0.50)) * gaussianWeights[i]; }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 0 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 1 <= 1 ? 6. : 11.; float amount = (0.03 * amt) * ease(0, mix(inner, outer, 0.50)); color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.50, 1. - 0.50)) * gaussianWeights[i]; }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 1 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 2 <= 1 ? 6. : 11.; float amount = (0.03 * amt) * ease(0, mix(inner, outer, 0.50)); color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.50, 1. - 0.50)) * gaussianWeights[i]; }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 2 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 3 <= 1 ? 6. : 11.; float amount = (0.03 * amt) * ease(0, mix(inner, outer, 0.50)); color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.50, 1. - 0.50)) * gaussianWeights[i]; }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 3 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":true,"depth":false,"passes":[{"prop":"vertical","value":1,"downSample":true},{"prop":"vertical","value":2,"downSample":true},{"prop":"vertical","value":3,"downSample":true}]}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"bulge","trackMouse":-0.5,"mouseMomentum":0.88,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord; in float zPos;uniform sampler2D uTexture; vec3 Tonemap_ACES(vec3 x) { const float a = 2.51; const float b = 0.03; const float c = 2.43; const float d = 0.59; const float e = 0.14; return (x * (a * x + b)) / (x * (c * x + d) + e); }out vec4 fragColor; void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);float intensity = 0.00 * 0.5;float rad = (0.50 - 0.25) * -2. * 3.14159; vec2 rotatedLightPosition = vec2(cos(rad), sin(rad)); vec3 lightPosition = vec3(vec2(0.5) * rotatedLightPosition * 2., 1.0);float diff = max(dot(normalize(vVertexPosition), lightPosition), 0.0); color.rgb += (diff * intensity - intensity); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;out vec2 vTextureCoord; out vec3 vVertexPosition; out float zPos; uniform sampler2D uTexture; uniform float uTime;uniform sampler2D uMaskTexture; uniform vec2 uMousePos; uniform vec2 uResolution;float ease (int easingFunc, float t) { switch(3) { case 0: return t; break; case 1: return t * t; break; case 2: return t * (2.0 - t); break; case 3: return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; break; case 4: return t * t * t; break; case 5: return --t * t * t + 1.0; break; case 6: return t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0; break; case 7: return t * t * t * t; break; case 8: return 1.0 - (--t) * t * t * t; break; case 9: return t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * (--t) * t * t * t; break; case 10: return t * t * t * t * t; break; case 11: return 1.0 + (--t) * t * t * t * t; break; case 12: return t < 0.5 ? 16.0 * t * t * t * t * t : 1.0 + 16.0 * (--t) * t * t * t * t; break; case 13: return 1.0 - sqrt(1.0 - t * t); break; case 14: return sqrt((2.0 - t) * t); break; case 15: return t < 0.5 ? (1.0 - sqrt(1.0 - 4.0 * t * t)) / 2.0 : (sqrt(-((2.0 * t) - 3.0) * ((2.0 * t) - 1.0)) + 1.0) / 2.0; break; case 16: return t == 0.0 ? 0.0 : pow(2.0, 10.0 * (t - 1.0)); break; case 17: return t == 1.0 ? 1.0 : 1.0 - pow(2.0, -10.0 * t); break; case 18: return t == 0.0 ? 0.0 : t == 1.0 ? 1.0 : t < 0.5 ? pow(2.0, (20.0 * t) - 10.0) / 2.0 : (2.0 - pow(2.0, -20.0 * t + 10.0)) / 2.0; break; case 19: return 1.0 - cos((t * 3.141592654) / 2.0); break; case 20: return sin((t * 3.141592654) / 2.0); break; case 21: return -(cos(3.141592654 * t) - 1.0) / 2.0; break; case 22: return t == 0.0 ? 0.0 : t == 1.0 ? 1.0 : -pow(2.0, 10.0 * t - 10.0) * sin((t * 10.0 - 10.75) * ((2.0 * 3.141592654) / 3.0)); break; case 23: return t == 0.0 ? 0.0 : t == 1.0 ? 1.0 : pow(2.0, -10.0 * t) * sin((t * 10.0 - 0.75) * ((2.0 * 3.141592654) / 3.0)) + 1.0; break; case 24: return t == 0.0 ? 0.0 : t == 1.0 ? 1.0 : t < 0.5 ? -(pow(2.0, 20.0 * t - 10.0) * sin((20.0 * t - 11.125) * ((2.0 * 3.141592654) / 4.5))) / 2.0 : (pow(2.0, -20.0 * t + 10.0) * sin((20.0 * t - 11.125) * ((2.0 * 3.141592654) / 4.5))) / 2.0 + 1.0; break; } }float bezier(float t) { return ease(3, t); }mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 bulge(vec3 pos) { vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1); vec2 mousePosAdjusted = mix((vec2(0.5, 0.5) - 0.5) * 2., (uMousePos - 0.5) * 2., -0.50); vec2 skew = vec2(0.50, 1.-0.50); mat2 rotation = rot(0.50 * 2. * 3.14159);float dist = distance(pos.xy * aspectRatio * rotation * skew, mousePosAdjusted * aspectRatio * rotation * skew);float t = max(0., 1. - dist/1.00); float bulge = bezier(t) * (0.76 - 0.5);float luma = dot(texture(uTexture, (pos.xy + 1.) * 0.5).rgb, vec3(0.299, 0.587, 0.114));bulge += luma * bezier(t) * 0.00; bulge = min(1., bulge);pos.xy += bulge * pos.xy; pos.z -= bulge; return pos; }void main() { vec3 pos = bulge(aVertexPosition); vec3 pos_dx = bulge(aVertexPosition + vec3(0.01, 0.0, 0.0)); vec3 pos_dy = bulge(aVertexPosition + vec3(0.0, 0.01, 0.0)); vec3 dx = pos_dx - pos; vec3 dy = pos_dy - pos; vec3 normal = normalize(cross(dx, dy));vVertexPosition = normal;zPos = pos.z;gl_Position = vec4(pos, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":true}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"vignette","trackMouse":0,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src; }out vec4 fragColor; void main() { vec2 uv = vTextureCoord;vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.00 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.) * vec2(0.00, 1.-0.00); float scaledRadius = 0.70 * 0.5;float adjustedRadius = scaledRadius + 0.80 * scaledRadius; float innerEdge = scaledRadius - 0.80 * scaledRadius * 0.5; float outerEdge = scaledRadius + 0.80 * scaledRadius * 0.5;vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.00);float radius = length(uv * aspectRatio - pos * aspectRatio); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);if(0 > 0) { vec3 blended = blend(0, vec3(0.08235294117647059, 0.08235294117647059, 0.10980392156862745), color.rgb); color.rgb = mix(color.rgb, blended, falloff * 1.00); } else { color.rgb = mix(color.rgb, mix(color.rgb, vec3(0.08235294117647059, 0.08235294117647059, 0.10980392156862745), 1.00), falloff); } fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false}},{"visible":true,"aspectRatio":1,"layerType":"effect","type":"blur","amount":0.22,"trackMouse":0.43,"mouseMomentum":0.93,"texture":false,"animating":false,"isMask":0,"states":{"appear":[{"type":"appear","id":"6d24504e-2268-412b-ad99-bf0bc4490ff7","prop":"amount","value":0,"transition":{"ease":"easeInOutQuart","duration":1000,"delay":300},"complete":false,"progress":0,"initialStateSet":false,"uniformData":{"type":"1f","name":"uAmount"}}],"scroll":[]},"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uAmount; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.43); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 0 <= 1 ? 6. : 11.; float amount = (uAmount * amt) * ease(0, mix(inner, outer, 0.86)); color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.00, 1. - 0.00)) * gaussianWeights[i]; }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 0 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uAmount; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.43); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 1 <= 1 ? 6. : 11.; float amount = (uAmount * amt) * ease(0, mix(inner, outer, 0.86)); color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.00, 1. - 0.00)) * gaussianWeights[i]; }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 1 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uAmount; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.43); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 2 <= 1 ? 6. : 11.; float amount = (uAmount * amt) * ease(0, mix(inner, outer, 0.86)); color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.00, 1. - 0.00)) * gaussianWeights[i]; }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 2 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uAmount; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const int kernelSize = 36; const float gaussianWeights[kernelSize] = float[](0.00094768, 0.00151965, 0.00237008, 0.00359517, 0.0053041, 0.00761097, 0.01062197, 0.01441804, 0.01903459, 0.0244409, 0.03052299, 0.03707432, 0.04379813, 0.05032389, 0.05623791, 0.06112521, 0.06461716, 0.06643724, 0.06643724, 0.06461716, 0.06112521, 0.05623791, 0.05032389, 0.04379813, 0.03707432, 0.03052299, 0.0244409, 0.01903459, 0.01441804, 0.01062197, 0.00761097, 0.0053041, 0.00359517, 0.00237008, 0.00151965, 0.00094768);vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.43); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 3 <= 1 ? 6. : 11.; float amount = (uAmount * amt) * ease(0, mix(inner, outer, 0.86)); color += texture(tex, uv) * gaussianWeights[0]; for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.00, 1. - 0.00)) * gaussianWeights[i]; }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither; return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv = vTextureCoord; vec4 color = vec4(0); int dir = 3 % 2; vec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":true,"depth":false,"passes":[{"prop":"vertical","value":1,"downSample":true},{"prop":"vertical","value":2,"downSample":true},{"prop":"vertical","value":3,"downSample":true}]}}],"options":{"name":"\"Raycast\" bg","fps":120,"dpi":2,"scale":1,"includeLogo":false,"isProduction":1,"version":"1.2.7"},"version":"1.2.7"}